// examples/verify-callback-example.ts

// Import directly from src for running locally before publishing
// In a real project, you'd import from 'digiid-ts' after installing
// Revert extension, ts-node should handle this when configured
import { DigiIDCallbackData, DigiIDError, verifyDigiIDCallback } from '../src/index';

console.log('--- DigiID Callback Verification Example ---');

// --- Mock Data & Setup ---

// This would normally come from your session/database lookup based on the request
const EXPECTED_NONCE = '61616161616161616161616161616161'; // Matches default nonce from crypto mock
const EXPECTED_CALLBACK_URL = 'https://myapp.example.com/api/auth/digiid';

// This data would normally come from the POST request body sent by the wallet
const mockCallbackData: DigiIDCallbackData = {
  address: 'D7dVskXFpH8gTgZG9sN3d6dPUbJtZfJ2Vc', // A syntactically valid address
  // URI containing the expected callback and nonce
  // eslint-disable-next-line no-unexpected-multiline // False positive likely due to template literal parsing?
  uri: `digiid://myapp.example.com/api/auth/digiid?x=${EXPECTED_NONCE}&u=0`,
  // IMPORTANT: This is a placeholder signature! 
  // Real verification requires a valid signature generated by a wallet signing the URI.
  // This example will likely fail signature verification if run against the real library,
  // unless the underlying verify function is mocked/stubbed.
  signature: 'AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiYw==',
};

// Verification options derived from our expected state
const verifyOptions = {
  expectedCallbackUrl: EXPECTED_CALLBACK_URL,
  expectedNonce: EXPECTED_NONCE,
};

// --- Simulation Function ---

async function simulateVerification(data: DigiIDCallbackData, options: typeof verifyOptions) {
  console.log('\nAttempting verification with:');
  console.log(`  Address: ${data.address}`);
  console.log(`  URI: ${data.uri}`);
  console.log(`  Signature: ${data.signature.substring(0, 30)}...`);
  console.log(`  Expected URL: ${options.expectedCallbackUrl}`);
  console.log(`  Expected Nonce: ${options.expectedNonce}`);

  try {
    const result = await verifyDigiIDCallback(data, options);
    console.log('\nVerification Successful!');
    console.log(`  Address Verified: ${result.address}`);
    console.log(`  Nonce Verified: ${result.nonce}`);
    // In a real app: log user in, mark nonce as used, etc.

  } catch (error) {
    if (error instanceof DigiIDError) {
      console.error(`\nVerification Failed: ${error.message}`);
      // In a real app: return 400 Bad Request
    } else {
      console.error('\nUnexpected Verification Error:', error);
      // In a real app: return 500 Internal Server Error
    }
  }
}

// --- Run Simulation ---

// Simulate verifying the correct data (likely fails signature check without mocks)
// We wrap this in an async IIFE (Immediately Invoked Function Expression) 
// to use await at the top level.
(async () => {
  await simulateVerification(mockCallbackData, verifyOptions);

  // Example: Simulate a Nonce Mismatch
  console.log('\n--- Simulating Nonce Mismatch ---');
  await simulateVerification(
    mockCallbackData,
    { ...verifyOptions, expectedNonce: 'DIFFERENT_NONCE' }
  );

  // Example: Simulate a URL Mismatch
  console.log('\n--- Simulating URL Mismatch ---');
  await simulateVerification(
    mockCallbackData,
    { ...verifyOptions, expectedCallbackUrl: 'https://wrongsite.com/callback' }
  );

  // Example: Simulate missing signature
  console.log('\n--- Simulating Missing Signature ---');
  await simulateVerification(
    { ...mockCallbackData, signature: '' },
    verifyOptions
  );

  console.log('\n--- End of Verification Example ---');
})();
